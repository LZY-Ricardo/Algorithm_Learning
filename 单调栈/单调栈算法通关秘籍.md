# 单调栈算法通关秘籍：从“温度”到“雨水”，一网打尽！

## 1. 单调栈是什么？——生活中的“排队”哲学

还记得小时候排队买冰淇淋吗？假如每个人的身高都不一样，大家都想知道自己前面第一个比自己高的人是谁。你会怎么做？——没错，这就是单调栈的雏形！

**单调栈**，顾名思义，就是栈内元素保持单调（递增或递减）顺序。它的最大用处，就是帮我们高效地解决“下一个更大/小元素”这类问题。

- **单调递增栈**：栈顶到栈底元素递增，适合找“下一个更大元素”。
- **单调递减栈**：栈顶到栈底元素递减，适合找“下一个更小元素”。

> 生活小剧场：  
> 小明排队时发现，只有比自己高的人出现，自己才会被“弹出队伍”，否则就一直等下去。  
> ——“单调栈，排队不慌！”

---

## 2. 单调栈的基本套路与应用场景

单调栈的经典应用场景有：
- 找下一个更大/更小元素
- 区间最大/最小值
- 面积/体积计算（如柱状图、接雨水）

**套路总结**：
1. 用栈存储元素的下标（而不是值），方便计算距离。
2. 遍历数组时，遇到“破坏单调性”的元素就弹栈并处理。
3. 栈为空时要注意边界情况。

---

## 3. 题目实战

### 3.1 496. 下一个更大元素 I

#### 题目简介
给定两个数组 nums1 和 nums2，nums1 是 nums2 的子集。对于 nums1 中的每个元素，找出它在 nums2 中右边第一个比它大的元素，没有则返回 -1。

#### 详细图解

假设 nums2 = [2, 1, 3, 5, 4]，nums1 = [1, 2, 4]

| 步骤 | 当前元素 | 栈内容（存下标） | hashTable 映射 | 说明 |
|------|----------|------------------|----------------|------|
| 1    | 2        | [0]              | {}             | 2入栈 |
| 2    | 1        | [0,1]            | {}             | 1入栈 |
| 3    | 3        | [2]              | {1:3, 0:3}     | 3>1，弹1，1的下一个更大是3；3>2，弹0，2的下一个更大是3；3入栈 |
| 4    | 5        | [3]              | {1:3, 0:3, 2:5}| 5>3，弹3，3的下一个更大是5；5入栈 |
| 5    | 4        | [3,4]            | {1:3, 0:3, 2:5}| 4入栈 |

**可视化动画：**

```
初始：栈 []
遍历2：栈 [2]
遍历1：栈 [2,1]
遍历3：3>1，弹1，1->3；3>2，弹2，2->3；栈 [3]
遍历5：5>3，弹3，3->5；栈 [5]
遍历4：栈 [5,4]
```

**最终查 nums1：**
- 1 -> 3
- 2 -> 3
- 4 -> -1

#### 代码实现

```javascript
var nextGreaterElement = function(nums1, nums2) {
    let hashTable = new Map();
    let stack = [];
    for (let i = 0; i < nums2.length; i++) {
        while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {
            let index = stack.pop();
            hashTable.set(nums2[index], nums2[i]);
        }
        stack.push(i);
    }
    return nums1.map(num => hashTable.get(num) ?? -1);
};
```

#### 幽默点评

> 单调栈就像“八卦小分队”，谁比我高，谁是我的“下一个目标”，一查一个准！

---

### 3.2 503. 下一个更大元素 II

#### 题目简介
给定一个循环数组，找每个元素的下一个更大元素。没有则返回 -1。

#### 详细图解

nums = [1, 2, 1]

**第一圈：**

| i | nums[i] | 栈内容 | res    | 说明 |
|---|---------|--------|--------|------|
| 0 | 1       | [0]    | [-1,-1,-1] | 1入栈 |
| 1 | 2       | [1]    | [2,-1,-1]  | 2>1，弹0，0的下一个更大是2；2入栈 |
| 2 | 1       | [1,2]  | [2,-1,-1]  | 1入栈 |

**第二圈（i=3,4,5）：**

| i | nums[i%n] | 栈内容 | res    | 说明 |
|---|-----------|--------|--------|------|
| 3 | 1         | [1,2]  | [2,-1,-1] | 1<=1，入栈（但i>=n不再入栈）|
| 4 | 2         | [1]    | [2,-1,2]  | 2>1，弹2，2的下一个更大是2 |
| 5 | 1         | [1]    | [2,-1,2]  | 1<=2，跳过 |

**动画描述：**

- 第一圈，2把1弹出，1的下一个更大是2。
- 第二圈，2把最后一个1弹出，2的下一个更大是2（循环）。

#### 代码实现

```javascript
var nextGreaterElements = function(nums) {
    let n = nums.length;
    let res = new Array(n).fill(-1);
    let stack = [];
    for (let i = 0; i < 2 * n; i++) {
        while (stack.length && nums[i % n] > nums[stack[stack.length - 1]]) {
            let index = stack.pop();
            res[index] = nums[i % n];
        }
        if (i < n) stack.push(i);
    }
    return res;
};
```

#### 幽默点评

> “转两圈，机会多多”，循环数组的单调栈，绝不让任何一个元素“孤独终老”！

---

### 3.3 739. 每日温度

#### 题目简介
给定一组每日气温，返回每一天需要等几天才会升温。如果之后都不会升温，返回 0。

#### 详细图解

temperatures = [73, 74, 75, 71, 69, 72, 76, 73]

| i | 当前温度 | 栈内容（下标） | res         | 说明 |
|---|----------|----------------|-------------|------|
| 0 | 73       | [0]            | [0,0,0,0,0,0,0,0] | 73入栈 |
| 1 | 74       | [1]            | [1,0,0,0,0,0,0,0] | 74>73，弹0，res[0]=1-0=1；74入栈 |
| 2 | 75       | [2]            | [1,1,0,0,0,0,0,0] | 75>74，弹1，res[1]=2-1=1；75入栈 |
| 3 | 71       | [2,3]          | [1,1,0,0,0,0,0,0] | 71入栈 |
| 4 | 69       | [2,3,4]        | [1,1,0,0,0,0,0,0] | 69入栈 |
| 5 | 72       | [2,3,5]        | [1,1,0,2,1,0,0,0] | 72>69，弹4，res[4]=5-4=1；72>71，弹3，res[3]=5-3=2；72入栈 |
| 6 | 76       | [6]            | [1,1,4,2,1,1,0,0] | 76>72，弹5，res[5]=6-5=1；76>75，弹2，res[2]=6-2=4；76入栈 |
| 7 | 73       | [6,7]          | [1,1,4,2,1,1,0,0] | 73入栈 |

**动画描述：**

- 每次遇到更高温度，弹出栈顶，计算距离。
- 栈里存的都是“还没等到升温”的天数下标。

#### 代码实现

```javascript
var dailyTemperatures = function(temperatures) {
    const len = temperatures.length;
    let res = new Array(len).fill(0);
    let stack = [];
    for (let i = 0; i < len; i++) {
        while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
            let index = stack.pop();
            res[index] = i - index;
        }
        stack.push(i);
    }
    return res;
};
```

#### 幽默点评

> “升温预报员上线：有了单调栈，妈妈再也不用担心我穿错衣服了！”

---

### 3.4 84. 柱状图中最大的矩形

#### 题目简介
给定一组柱状图的高度，求能围成的最大矩形面积。

#### 详细图解

heights = [2,1,5,6,2,3]

**加哨兵后：** [0,2,1,5,6,2,3,0]

| i | 当前高度 | 栈内容（下标） | 计算面积 | maxArea | 说明 |
|---|----------|----------------|----------|---------|------|
| 0 | 0        | [0]            | -        | 0       | 0入栈 |
| 1 | 2        | [0,1]          | -        | 0       | 2入栈 |
| 2 | 1        | [0,2]          | 2x1=2    | 2       | 1<2，弹1，面积2；1入栈 |
| 3 | 5        | [0,2,3]        | -        | 2       | 5入栈 |
| 4 | 6        | [0,2,3,4]      | -        | 2       | 6入栈 |
| 5 | 2        | [0,2,3,5]      | 6x1=6, 5x2=10 | 10 | 2<6，弹4，面积6；2<5，弹3，面积10；2入栈 |
| 6 | 3        | [0,2,3,5,6]    | -        | 10      | 3入栈 |
| 7 | 0        | [0,2,7]        | 3x1=3, 2x4=8, 1x6=6 | 10 | 0<3，弹6，面积3；0<2，弹5，面积8；0<1，弹2，面积6；0入栈 |

**动画描述：**

- 每次遇到更矮的柱子，弹栈并计算以弹出柱子为高的最大矩形面积。
- 宽度=当前下标-新栈顶下标-1。

#### 代码实现

```javascript
var largestRectangleArea = function(heights) {
    heights.unshift(0);
    heights.push(0);
    let stack = [0];
    let maxArea = 0;
    for (let i = 1; i < heights.length; i++) {
        while (heights[i] < heights[stack[stack.length - 1]]) {
            let mid = stack.pop();
            let height = heights[mid];
            let width = i - stack[stack.length - 1] - 1;
            maxArea = Math.max(maxArea, height * width);
        }
        stack.push(i);
    }
    return maxArea;
};
```

#### 幽默点评

> “最大矩形面积？单调栈一出手，谁与争锋！积木王国的面积大比拼！”

---

### 3.5 42. 接雨水

#### 题目简介
给定一组柱子的高度，问下雨后能接多少水。

#### 详细图解

height = [0,1,0,2,1,0,1,3,2,1,2,1]

| i | 当前高度 | 栈内容（下标） | 计算雨水 | 总水量 | 说明 |
|---|----------|----------------|----------|--------|------|
| 0 | 0        | [0]            | -        | 0      | 0入栈 |
| 1 | 1        | [1]            | 0        | 0      | 1>0，弹0，无左界，1入栈 |
| 2 | 0        | [1,2]          | -        | 0      | 0入栈 |
| 3 | 2        | [1,3]          | 1x1=1    | 1      | 2>0，弹2，h=1-0=1,w=3-1-1=1；2>1，弹1，无左界，3入栈 |
| 4 | 1        | [1,3,4]        | -        | 1      | 1入栈 |
| 5 | 0        | [1,3,4,5]      | -        | 1      | 0入栈 |
| 6 | 1        | [1,3,4,6]      | 1x1=1    | 2      | 1>0，弹5，h=1-0=1,w=6-4-1=1；1入栈 |
| 7 | 3        | [1,3,7]        | 2x3=6    | 8      | 3>1，弹6，h=2-1=1,w=7-4-1=2；3>1，弹4，h=2-1=1,w=7-3-1=3；3>2，弹3，h=2-1=1,w=7-1-1=5；3入栈 |
| ... | ...    | ...            | ...      | ...    | ...  |

**动画描述：**

- 每次遇到更高的柱子，弹栈并计算“凹槽”能接的水。
- h=两边较矮高度-中间高度，w=两边下标之差-1。

#### 代码实现

```javascript
var trap = function(height) {
    let n = height.length, res = 0, stack = [];
    for (let i = 0; i < n; i++) {
        while (stack.length && height[i] > height[stack[stack.length - 1]]) {
            let mid = stack.pop();
            if (!stack.length) break;
            let h = Math.min(height[i], height[stack[stack.length - 1]]) - height[mid];
            let w = i - stack[stack.length - 1] - 1;
            res += h * w;
        }
        stack.push(i);
    }
    return res;
};
```

#### 幽默点评

> “下雨天，单调栈帮你兜住每一滴水，妈妈再也不用担心我家漏水啦！”

---

## 4. 单调栈套路总结与常见陷阱

- 栈里存下标，方便计算距离。
- 注意边界处理，尤其是“栈空”时。
- 循环数组要“转两圈”。
- 题目问“值”还是“距离”，要分清楚。

---

## 5. 互动练习与思考题

1. 你能用单调栈解决“下一个更小元素”问题吗？试试吧！
2. 柱状图最大矩形还有哪些优化思路？
3. 如果温度是递减的，单调栈会发生什么？

---

如果你喜欢这样的讲解，记得点赞收藏哦！单调栈算法，学会了就是你的“排队神器”！🎉
